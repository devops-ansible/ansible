---

- name: Define install env
  # k3s_install_env:
  #   - name: K3S_URL
  #     value: https://myserver:6443
  #   - name: K3S_TOKEN
  #     value: mynodetoken
  ansible.builtin.set_fact:
    final_k3s_install_env: "{{ final_k3s_install_env }} {{ item.key }}=\"{{ item.value }}\""
  loop: "{{ k3s_install_env | dict2items }}"
  when:
    - k3s_install_env is defined
    - k3s_install_env | length > 0

- name: "Install all prerequisite tools needed for this install routine"
  ansible.builtin.package:
    name: "{{ item.name }}"
    state: "{{ item.state | default( package_state) }}"
  with_items: "{{ install_k3s.prerequisites }}"

- name: "k3s installation"
  become: true
  block:

    - name: "Ensure data real storage locations"
      ansible.builtin.file:
        path: "{{ item.src | default( item.k3s ) }}"
        state: "directory"
        recurse: false
        owner: root
        group: root
      loop: "{{ k3s_data_dirs }}"

    - name: "Ensure links of storage locations"
      ansible.builtin.include_tasks: _k3s_linking.yml
      loop: "{{ k3s_data_dirs }}"
      vars:
        path_dict: item
      when: item.src is defined

    - name: "Install k3s via install script"
      ansible.builtin.shell: |
        set -x
        pre_installed=$( k3s --version || echo "" )
        set -ex
        curl -sfL https://get.k3s.io |{{ final_k3s_install_env }} sh -
        post_installed=$( k3s --version || echo "" )
        jq -c --null-input \
          --arg pre "${pre_installed}" \
          --arg post "${post_installed}" \
          '{"pre": $pre, "post": $post}'
      register: inst
      changed_when: inst.stdout_lines[-1] | from_json | json_query('pre') != inst.stdout_lines[-1] | from_json | json_query('post')

- name: "CNI installation"
  become: true
  when: install_containernetworking_cni
  block:

    - name: "Ensure GoLang installed"
      ansible.builtin.include_role:
        name: golang

    - name: "fetch latest version"
      ansible.builtin.set_fact:
        cni_git_tag: "{{ ( lookup('ansible.builtin.url', 'https://api.github.com/repos/{{ cni_plugin_gitrepo }}/releases/latest', wantlist=False) | from_json )['tag_name'] }}"
      when:
        - cni_plugins_version == "latest"

    - name: "fetch containernetworking plugins"
      ansible.builtin.git:
        repo: 'https://github.com/{{ item }}.git'
        dest: "{{ cni_plugins_path }}"
        version: "{{ cni_git_tag | default( cni_plugins_version ) }}"
      with_items:
        - "{{ cni_plugin_gitrepo }}"
      register: cni_git_changed

    - name: "install CNI plugins"
      ansible.builtin.shell:
        cmd: |
          . /etc/profile
          go get github.com/containernetworking/cni
          go install github.com/containernetworking/cni/cnitool
          cd {{ cni_plugins_path }}
          ./build_linux.sh
      when: cni_git_changed.changed

- name: "nerdctl installation"
  become: true
  block:

    - name: "nerdctl – release"
      uri:
        url: "https://api.github.com/repos/containerd/nerdctl/releases/{{ version }}"
        return_content: true
      register: nerdctl_info
      check_mode: false
      vars:
        n_version: "{{ k3s_nerdctl_version }}"
        n_tag: "tags/v{{ k3s_nerdctl_version }}"
        version: "{{ (k3s_nerdctl_version == 'latest') | ternary(n_version, n_tag) }}"

    - name: "nerdctl – release data"
      ansible.builtin.set_fact:
        nerdctl_version: "{{ tag }}"
        nerdctl_asset: "{{ nerdctl_info.json | json_query(jq_binary) | first }}"
        nerdctl_chksum_asset: "{{ chksum_asset | combine(merge_chksum_asset) }}"
      vars:
        tag: "{{ nerdctl_info.json.tag_name }}"
        version: "{{ tag | regex_replace('^v', '') }}"
        bin: "nerdctl-full-{{ version }}-linux-{{ containerd_arch }}.tar.gz"
        jq_binary: "assets[?name==`{{ bin }}`]"
        jq_chksum: "assets[?name==`SHA256SUMS`]"
        chksum_asset: "{{ nerdctl_info.json | json_query(jq_chksum) | first }}"
        merge_chksum_asset:
            name: "{{ bin }}.sha256sums"

    - name: "Create temporary download directory"
      ansible.builtin.tempfile:
        state: "directory"
        suffix: "_nerdctl"
      changed_when: false
      register: "tmp_dl_dir"

    - name: "Ensure nerdctl parent folder"
      ansible.builtin.file:
        path: "{{ k3s_nerdctl_path }}"
        state: "directory"
        recurse: true
        owner: root
        group: root

    - name: "Download nerdctl"
      get_url:
        url: "{{ item.browser_download_url }}"
        dest: "{{ tmp_dl_dir.path }}/{{ item.name | default('') }}"
        owner: root
        group: root
        mode: 0644
      loop:
        - "{{ nerdctl_asset | default({}) }}"
        - "{{ nerdctl_chksum_asset | default({}) }}"
      changed_when: false
      when:
        - item.browser_download_url is defined

    - name: "check nerdctl binaries checksum"
      shell: |
        set -ex
        cd "{{ tmp_dl_dir.path }}"
        grep {{ nerdctl_asset.name }} {{ nerdctl_chksum_asset.name }} | sha256sum -c - > /dev/null
      register: rt
      changed_when: rt.stdout_lines | length > 0
      check_mode: false

    - name: "unarchive nerdctl binaries"
      ansible.builtin.unarchive:
        src: "{{ tmp_dl_dir.path }}/{{ nerdctl_asset.name }}"
        remote_src: true
        dest: "{{ k3s_nerdctl_path }}"

    - name: "prepare nerdctl config directory"
      ansible.builtin.file:
        path: "{{ nerdctl_config_path | dirname }}"
        state: "directory"
        recurse: true
        owner: root
        group: root

    - name: "nerdctl configuration"
      ansible.builtin.template:
        dest: "{{ nerdctl_config_path }}"
        src: "data.toml"
      vars:
        pre_toml: |
          # This is /etc/nerdctl/nerdctl.toml .
          # Unrelated to the daemon's /etc/containerd/config.toml .
        data: "{{ nerdctl_config }}"

    - name: "ensure nerdctl bin files in PATH"
      ansible.builtin.blockinfile:
        path: /etc/profile
        marker: "# {mark} ANSIBLE MANAGED BLOCK (role {{ ansible_role_name }})"
        block: |
          export PATH="$PATH:{{ k3s_nerdctl_path }}/bin"
        create: true

    - name: "Create docker link to real storage for {{ k3s_dest }}"
      ansible.builtin.file:
        src: "{{ k3s_nerdctl_path }}/bin/nerdctl"
        dest: "/usr/bin/docker"
        state: "link"
        owner: root
        group: root

    - name: "test nerdctl command"
      ansible.builtin.shell: |
        . /etc/profile
        nerdctl run --rm hello-world
      changed_when: false

    - name: "check if docker alias is reachable"
      ansible.builtin.command: "which docker"
      changed_when: false

  always:

    - name: Clean temporary directory
      ansible.builtin.file:
        path: "{{ tmp_dl_dir.path }}"
        state: absent
      changed_when: false
      when: tmp_dl_dir.path is defined

- name: "ensure `containerd` configuration file written out"
  # the containderd login to registries should be defined like that to be respected here:
  #
  # container_registries:
  #   - url: "docker.io"
  #     auth:
  #       username: "@@@@@"
  #       password: "*****"
  #   - url: "localhost:5555"
  #     tls:
  #       # better than that is to use `containerd_registry_tls_config_path` variable
  #       # and configure tls ignorance over there. see e.g.
  #       # https://medium.com/@schottz/how-to-skip-tls-verify-fot-internal-registry-on-containerd-e039887bcb83
  #       insecure_skip_verify = true
  #     auth:
  #       username: "@@@@@"
  #       password: "*****"
  become: true
  block:

    - name: "check path file existence {{ containerd_config_path }}"
      ansible.builtin.stat:
        path: "{{ containerd_config_path }}"
      register: contd_conf_ex
      changed_when: false

    # - name: "get current config from existing config file"
    #   ansible.builtin.command: "cat {{ containerd_config_path }}"
    #   register: contd_conf1
    #   when: contd_conf_ex.stat.exists

    - name: "ensure directory for config file {{ containerd_config_path | dirname }}"
      ansible.builtin.file:
        path: "{{ containerd_config_path | dirname }}"
        state: "directory"
        recurse: true
        owner: root
        group: root
      when: not contd_conf_ex.stat.exists

    - name: "fetch default config for containerd"
      ansible.builtin.command: "{{ k3s_nerdctl_path }}/bin/containerd config default"
      register: contd_conf
      changed_when: false
      check_mode: false
      # when: not contd_conf_ex.stat.exists

    - name: gather information
      ansible.builtin.set_fact:
        containerd_registry_configs: "{{ containerd_registry_configs | default( {} ) | ansible.builtin.combine( { item.pop('url'): item } ) }}"
      no_log: true
      with_items: "{{ container_registries }}"
      when:
        - container_registries is defined
        - container_registries | length > 0

    - name: "prepare enriching of containerd config"
      ansible.builtin.set_fact:
        json_conf:
          plugins:
            io.containerd.grpc.v1.cri:
              registry:
                # config_path e.g. could be `/etc/containerd/certs.d`
                config_path: '{{ containerd_registry_tls_config_path | default( "" ) }}'
                configs: "{{ containerd_registry_configs | default( {} ) }}"
      when:
        - containerd_registry_configs is defined

    - name: "enrich containerd config"
      ansible.builtin.set_fact:
        contd_conf: "{{ ( contd_conf.stdout | from_toml ) | ansible.builtin.combine( ( json_conf | default( {} ) ), recursive=true ) }}"

    - name: "write out containerd configuration to {{ containerd_config_path }}"
      ansible.builtin.template:
        dest: "{{ containerd_config_path }}"
        src: "data.toml"
      vars:
        data: "{{ contd_conf }}"

...
